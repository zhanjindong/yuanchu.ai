<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>流量统计 - 元初AI</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
        }
        #canvas { position: fixed; top: 0; left: 0; z-index: 0; }
        .content {
            position: relative;
            z-index: 1;
            padding: 40px 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .back {
            display: inline-block;
            font-size: 14px;
            color: rgba(255,255,255,0.4);
            text-decoration: none;
            letter-spacing: 4px;
            margin-bottom: 60px;
            transition: color 0.3s;
        }
        .back:hover { color: #fff; }
        .back::before { content: '← '; }
        .section-title {
            font-size: 14px;
            color: rgba(255,255,255,0.4);
            letter-spacing: 12px;
            text-transform: uppercase;
            margin-bottom: 20px;
        }
        h1 {
            font-size: 48px;
            font-weight: 300;
            letter-spacing: 12px;
            margin-bottom: 12px;
        }
        .subtitle {
            font-size: 13px;
            color: rgba(255,255,255,0.3);
            letter-spacing: 2px;
            margin-bottom: 40px;
        }

        .loading {
            text-align: center;
            padding: 80px 0;
            color: rgba(255,255,255,0.4);
            font-size: 14px;
            letter-spacing: 4px;
        }
        .loading .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.1);
            border-top-color: rgba(255,255,255,0.6);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-bottom: 16px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .error-msg {
            text-align: center;
            padding: 60px 0;
            color: rgba(255,100,100,0.8);
            font-size: 14px;
            letter-spacing: 2px;
        }
        .error-msg .retry-btn {
            display: inline-block;
            margin-top: 16px;
            padding: 8px 24px;
            font-size: 13px;
            color: rgba(255,255,255,0.6);
            background: none;
            border: 1px solid rgba(255,255,255,0.2);
            cursor: pointer;
            transition: all 0.3s;
            letter-spacing: 2px;
            font-family: inherit;
        }
        .error-msg .retry-btn:hover {
            color: #fff;
            border-color: rgba(255,255,255,0.5);
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            margin-bottom: 40px;
        }
        .metric-card {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 24px;
            transition: all 0.3s;
        }
        .metric-card:hover {
            background: rgba(255,255,255,0.08);
            border-color: rgba(255,255,255,0.2);
        }
        .metric-label {
            font-size: 12px;
            color: rgba(255,255,255,0.4);
            letter-spacing: 2px;
            margin-bottom: 8px;
        }
        .metric-value {
            font-size: 32px;
            font-weight: 300;
            letter-spacing: 2px;
            color: rgba(255,255,255,0.9);
        }
        .metric-sub {
            font-size: 11px;
            color: rgba(255,255,255,0.25);
            margin-top: 4px;
            letter-spacing: 1px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
            margin-bottom: 32px;
        }
        .range-btns {
            display: flex;
            gap: 0;
        }
        .range-btn {
            padding: 8px 20px;
            font-size: 13px;
            color: rgba(255,255,255,0.5);
            background: none;
            border: 1px solid rgba(255,255,255,0.15);
            cursor: pointer;
            transition: all 0.3s;
            letter-spacing: 2px;
            font-family: inherit;
        }
        .range-btn:not(:first-child) { border-left: none; }
        .range-btn:hover {
            color: rgba(255,255,255,0.8);
            background: rgba(255,255,255,0.05);
        }
        .range-btn.active {
            color: #fff;
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.3);
        }
        .range-btn.active + .range-btn { border-left-color: rgba(255,255,255,0.3); }
        .zone-select, .domain-select {
            padding: 8px 16px;
            font-size: 13px;
            color: rgba(255,255,255,0.6);
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.15);
            cursor: pointer;
            font-family: inherit;
            letter-spacing: 1px;
            appearance: none;
            -webkit-appearance: none;
            padding-right: 32px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='rgba(255,255,255,0.4)' d='M2 4l4 4 4-4'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
        }
        .zone-select:focus, .domain-select:focus {
            outline: none;
            border-color: rgba(255,255,255,0.3);
        }
        .zone-select option, .domain-select option {
            background: #111;
            color: #fff;
        }

        .chart-container {
            margin-bottom: 40px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 24px;
            position: relative;
        }
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        .chart-title {
            font-size: 14px;
            color: rgba(255,255,255,0.5);
            letter-spacing: 4px;
        }
        .trend-canvas {
            width: 100%;
            display: block;
        }
        .chart-tooltip {
            position: absolute;
            background: rgba(20,20,20,0.95);
            border: 1px solid rgba(255,255,255,0.2);
            padding: 10px 14px;
            font-size: 12px;
            color: rgba(255,255,255,0.8);
            pointer-events: none;
            z-index: 10;
            display: none;
            line-height: 1.8;
            letter-spacing: 1px;
            white-space: nowrap;
        }

        .table-section { margin-bottom: 40px; }
        .table-title {
            font-size: 14px;
            color: rgba(255,255,255,0.5);
            letter-spacing: 4px;
            margin-bottom: 16px;
        }
        .table-wrapper { overflow-x: auto; }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        thead th {
            text-align: left;
            padding: 12px 16px;
            font-weight: 400;
            font-size: 12px;
            color: rgba(255,255,255,0.4);
            letter-spacing: 2px;
            border-bottom: 1px solid rgba(255,255,255,0.15);
            white-space: nowrap;
        }
        thead th.sortable {
            cursor: pointer;
            user-select: none;
            transition: color 0.3s;
        }
        thead th.sortable:hover { color: rgba(255,255,255,0.7); }
        thead th.sorted-desc::after { content: ' ▼'; font-size: 10px; }
        thead th.sorted-asc::after { content: ' ▲'; font-size: 10px; }
        tbody tr {
            border-bottom: 1px solid rgba(255,255,255,0.06);
            transition: background 0.2s;
        }
        tbody tr:hover { background: rgba(255,255,255,0.04); }
        tbody td {
            padding: 12px 16px;
            color: rgba(255,255,255,0.7);
        }
        tbody td:first-child { color: rgba(255,255,255,0.85); }
        .num-cell {
            font-variant-numeric: tabular-nums;
            letter-spacing: 1px;
        }

        .bar-bg {
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.06);
            margin-top: 4px;
        }
        .bar-fill {
            height: 100%;
            background: rgba(100,180,255,0.5);
            transition: width 0.5s;
        }

        .two-col {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            margin-bottom: 40px;
        }

        .bar-chart-container {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 24px;
        }
        .bar-chart-title {
            font-size: 14px;
            color: rgba(255,255,255,0.5);
            letter-spacing: 4px;
            margin-bottom: 16px;
        }
        .bar-item {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            font-size: 13px;
        }
        .bar-label {
            width: 140px;
            color: rgba(255,255,255,0.6);
            letter-spacing: 1px;
            flex-shrink: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .bar-track {
            flex: 1;
            height: 6px;
            background: rgba(255,255,255,0.06);
            margin: 0 12px;
        }
        .bar-fill-h {
            height: 100%;
            transition: width 0.5s;
        }
        .bar-val {
            width: 70px;
            text-align: right;
            color: rgba(255,255,255,0.5);
            font-size: 12px;
            font-variant-numeric: tabular-nums;
        }

        .status-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .status-badge {
            padding: 6px 12px;
            font-size: 12px;
            font-variant-numeric: tabular-nums;
            letter-spacing: 1px;
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.03);
        }
        .status-badge.s2xx { border-color: rgba(100,255,160,0.3); color: rgba(100,255,160,0.8); }
        .status-badge.s3xx { border-color: rgba(100,180,255,0.3); color: rgba(100,180,255,0.8); }
        .status-badge.s4xx { border-color: rgba(255,200,100,0.3); color: rgba(255,200,100,0.8); }
        .status-badge.s5xx { border-color: rgba(255,100,100,0.3); color: rgba(255,100,100,0.8); }

        .security-metrics {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            margin-bottom: 24px;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: rgba(255,255,255,0.3);
            font-size: 14px;
            letter-spacing: 2px;
        }
        .empty-state p { margin-bottom: 12px; }

        footer {
            margin-top: 100px;
            padding-top: 40px;
            border-top: 1px solid rgba(255,255,255,0.1);
            text-align: center;
            font-size: 12px;
            color: rgba(255,255,255,0.3);
        }
        .data-source {
            font-size: 11px;
            color: rgba(255,255,255,0.2);
            letter-spacing: 1px;
            margin-top: 8px;
        }

        #dashboard { display: none; }

        @media (max-width: 768px) {
            h1 { font-size: 32px; letter-spacing: 8px; margin-bottom: 8px; }
            .metrics, .security-metrics { grid-template-columns: repeat(2, 1fr); gap: 12px; }
            .metric-value { font-size: 24px; }
            .metric-card { padding: 16px; }
            .controls { flex-direction: column; align-items: stretch; }
            .range-btns { width: 100%; }
            .range-btn { flex: 1; text-align: center; padding: 8px 8px; }
            .zone-select, .domain-select { width: 100%; }
            .chart-container { padding: 16px 12px; }
            .two-col { grid-template-columns: 1fr; }
            table { font-size: 13px; }
            thead th, tbody td { padding: 10px 10px; }
            .bar-label { width: 80px; font-size: 12px; }
        }
        @media (max-width: 480px) {
            .metrics, .security-metrics { grid-template-columns: 1fr 1fr; }
            .metric-value { font-size: 20px; }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="content">
        <a href="index.html" class="back">BACK</a>
        <div class="section-title">CLOUDFLARE ANALYTICS</div>
        <h1>流量统计</h1>
        <div class="subtitle">数据来源：Cloudflare GraphQL Analytics API · 纯静态页面直连</div>

        <div id="loadingState" class="loading">
            <div class="spinner"></div>
            <div>正在连接 Cloudflare...</div>
        </div>
        <div id="errorState" class="error-msg" style="display:none;"></div>

        <div id="dashboard">
            <div class="controls">
                <select class="zone-select" id="zoneSelect"></select>
                <div class="range-btns">
                    <button class="range-btn" data-range="1">今日</button>
                    <button class="range-btn active" data-range="7">7天</button>
                    <button class="range-btn" data-range="30">30天</button>
                </div>
                <select class="domain-select" id="domainFilter">
                    <option value="">全部域名</option>
                </select>
            </div>

            <div class="metrics">
                <div class="metric-card">
                    <div class="metric-label">总请求数</div>
                    <div class="metric-value" id="mRequests">-</div>
                    <div class="metric-sub" id="mRequestsSub"></div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">页面浏览量</div>
                    <div class="metric-value" id="mPageViews">-</div>
                    <div class="metric-sub" id="mPageViewsSub"></div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">独立访客 (UV)</div>
                    <div class="metric-value" id="mUniques">-</div>
                    <div class="metric-sub" id="mUniquesSub"></div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">总带宽</div>
                    <div class="metric-value" id="mBandwidth">-</div>
                    <div class="metric-sub" id="mBandwidthSub"></div>
                </div>
            </div>

            <!-- Trend Chart -->
            <div class="chart-container">
                <div class="chart-header">
                    <div class="chart-title">访问趋势</div>
                </div>
                <canvas id="trendChart" class="trend-canvas" height="300"></canvas>
                <div class="chart-tooltip" id="chartTooltip"></div>
            </div>

            <!-- Domain Table -->
            <div class="table-section">
                <div class="table-title">域名统计（含子域名）</div>
                <div class="table-wrapper">
                    <table id="domainTable">
                        <thead>
                            <tr>
                                <th>域名</th>
                                <th class="sortable" data-table="domain" data-key="requests">请求数</th>
                                <th class="sortable" data-table="domain" data-key="uniques">独立访客</th>
                                <th class="sortable" data-table="domain" data-key="bytes">带宽</th>
                                <th>占比</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>

            <!-- Page Table -->
            <div class="table-section">
                <div class="table-title">页面热度 TOP 30</div>
                <div class="table-wrapper">
                    <table id="pageTable">
                        <thead>
                            <tr>
                                <th>路径</th>
                                <th class="sortable" data-table="page" data-key="requests">请求数</th>
                                <th class="sortable" data-table="page" data-key="uniques">独立访客</th>
                                <th>占比</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>

            <!-- Geo & Browser -->
            <div class="two-col">
                <div class="bar-chart-container">
                    <div class="bar-chart-title">国家/地区分布 TOP 10</div>
                    <div id="geoBars"></div>
                </div>
                <div class="bar-chart-container">
                    <div class="bar-chart-title">浏览器分布</div>
                    <div id="browserBars"></div>
                </div>
            </div>

            <!-- Security & Performance -->
            <div class="table-section">
                <div class="table-title">安全与性能</div>
                <div class="security-metrics">
                    <div class="metric-card">
                        <div class="metric-label">威胁拦截</div>
                        <div class="metric-value" id="mThreats">-</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">HTTPS 占比</div>
                        <div class="metric-value" id="mHttps">-</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">缓存命中率</div>
                        <div class="metric-value" id="mCacheHit">-</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">节省带宽</div>
                        <div class="metric-value" id="mCachedBW">-</div>
                    </div>
                </div>
                <div class="table-title" style="margin-top:24px;">HTTP 状态码分布</div>
                <div class="status-grid" id="statusGrid"></div>
            </div>
        </div>

        <footer>
            <p>&copy; 2026 元初AI · ORIGIN OF INTELLIGENCE</p>
            <div class="data-source">数据来源：Cloudflare GraphQL Analytics API · 纯静态页面 · 无后端服务</div>
        </footer>
    </div>

    <script>
    (function() {
        // =========================================
        // Config
        // =========================================
        const CF_API_TOKEN = 'Mdyp9VMX2fFuWDIwxT3jW5HTOJaraGt_VRESSVjk';
        const CF_GQL = 'https://api.cloudflare.com/client/v4/graphql';
        const CF_REST = 'https://api.cloudflare.com/client/v4';

        // =========================================
        // Particle Background
        // =========================================
        const bgCanvas = document.getElementById('canvas');
        const bgCtx = bgCanvas.getContext('2d');
        let bgW, bgH, bgParticles = [], bgMouseX = 0, bgMouseY = 0, bgTargetX = 0, bgTargetY = 0;
        function bgResize() { bgW = bgCanvas.width = window.innerWidth; bgH = bgCanvas.height = window.innerHeight; }
        window.addEventListener('resize', bgResize);
        bgResize();
        class BgParticle {
            constructor() { this.reset(); }
            reset() { this.x = Math.random() * bgW; this.y = Math.random() * bgH; this.size = Math.random() * 1.5 + 0.5; this.speedX = (Math.random() - 0.5) * 0.3; this.speedY = (Math.random() - 0.5) * 0.3; this.alpha = Math.random() * 0.5 + 0.2; }
            update() { this.x += this.speedX + (bgTargetX - bgW/2) * 0.0001; this.y += this.speedY + (bgTargetY - bgH/2) * 0.0001; if (this.x < 0 || this.x > bgW || this.y < 0 || this.y > bgH) this.reset(); }
            draw() { bgCtx.beginPath(); bgCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2); bgCtx.fillStyle = `rgba(255,255,255,${this.alpha})`; bgCtx.fill(); }
        }
        for (let i = 0; i < 80; i++) bgParticles.push(new BgParticle());
        bgCanvas.addEventListener('mousemove', e => { bgMouseX = e.clientX; bgMouseY = e.clientY; });
        function bgAnimate() { bgCtx.fillStyle = 'rgba(0,0,0,0.1)'; bgCtx.fillRect(0, 0, bgW, bgH); bgTargetX += (bgMouseX - bgTargetX) * 0.05; bgTargetY += (bgMouseY - bgTargetY) * 0.05; bgParticles.forEach(p => { p.update(); p.draw(); }); requestAnimationFrame(bgAnimate); }
        bgAnimate();

        // =========================================
        // State
        // =========================================
        let zones = [];
        let currentZoneId = '';
        let currentZoneName = '';
        let currentRange = 7;
        let currentDomain = '';

        let dataOverview = null;
        let dataTrend = [];
        let dataDomains = [];
        let dataPages = [];
        let dataGeo = [];
        let dataBrowsers = [];
        let dataSecurity = null;

        let domainSortKey = 'requests';
        let domainSortDir = 'desc';
        let pageSortKey = 'requests';
        let pageSortDir = 'desc';

        // =========================================
        // DOM
        // =========================================
        const loadingEl = document.getElementById('loadingState');
        const errorEl = document.getElementById('errorState');
        const dashboardEl = document.getElementById('dashboard');
        const zoneSelect = document.getElementById('zoneSelect');
        const domainFilter = document.getElementById('domainFilter');
        const chartTooltip = document.getElementById('chartTooltip');

        // =========================================
        // Utility
        // =========================================
        function formatNum(n) {
            if (n == null || isNaN(n)) return '-';
            if (n >= 1000000) return (n / 1000000).toFixed(1) + 'M';
            if (n >= 10000) return (n / 1000).toFixed(1) + 'K';
            return n.toLocaleString('zh-CN');
        }

        function formatBytes(bytes) {
            if (bytes == null || isNaN(bytes)) return '-';
            if (bytes >= 1073741824) return (bytes / 1073741824).toFixed(2) + ' GB';
            if (bytes >= 1048576) return (bytes / 1048576).toFixed(2) + ' MB';
            if (bytes >= 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return bytes + ' B';
        }

        function escapeHtml(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        function getDateRange(days) {
            const end = new Date();
            const start = new Date();
            start.setDate(start.getDate() - days + 1);
            start.setHours(0, 0, 0, 0);
            return {
                since: start.toISOString().split('T')[0],
                until: end.toISOString().split('T')[0]
            };
        }

        function showLoading(msg) {
            loadingEl.style.display = 'block';
            loadingEl.querySelector('div:last-child').textContent = msg || '加载中...';
            errorEl.style.display = 'none';
            dashboardEl.style.display = 'none';
        }

        function showError(msg) {
            loadingEl.style.display = 'none';
            errorEl.style.display = 'block';
            errorEl.innerHTML = msg + '<br><button class="retry-btn" onclick="location.reload()">重试</button>';
            dashboardEl.style.display = 'none';
        }

        function showDashboard() {
            loadingEl.style.display = 'none';
            errorEl.style.display = 'none';
            dashboardEl.style.display = 'block';
        }

        // =========================================
        // Cloudflare REST API
        // =========================================
        async function cfRest(path) {
            const resp = await fetch(CF_REST + path, {
                headers: {
                    'Authorization': 'Bearer ' + CF_API_TOKEN,
                    'Content-Type': 'application/json'
                }
            });
            const data = await resp.json();
            if (!data.success) throw new Error(data.errors?.[0]?.message || 'API Error');
            return data.result;
        }

        // =========================================
        // Cloudflare GraphQL API
        // =========================================
        async function cfGql(query, variables) {
            const resp = await fetch(CF_GQL, {
                method: 'POST',
                headers: {
                    'Authorization': 'Bearer ' + CF_API_TOKEN,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ query, variables })
            });
            const data = await resp.json();
            if (data.errors && data.errors.length > 0) {
                throw new Error(data.errors[0].message);
            }
            return data.data;
        }

        // =========================================
        // Load zones
        // =========================================
        async function loadZones() {
            showLoading('正在获取域名列表...');
            try {
                const result = await cfRest('/zones?per_page=50');
                zones = result || [];
                if (zones.length === 0) {
                    showError('未找到任何域名。请确保 API Token 具有 Zone 读取权限，且账户下已添加域名。<br><br>当前 Token 状态：有效<br>可能原因：账户下尚未添加任何域名到 Cloudflare');
                    return false;
                }
                renderZoneSelect();
                currentZoneId = zones[0].id;
                currentZoneName = zones[0].name;
                return true;
            } catch (err) {
                showError('获取域名列表失败: ' + err.message);
                return false;
            }
        }

        function renderZoneSelect() {
            zoneSelect.innerHTML = '';
            zones.forEach(z => {
                const opt = document.createElement('option');
                opt.value = z.id;
                opt.textContent = z.name;
                zoneSelect.appendChild(opt);
            });
        }

        // =========================================
        // Load all analytics data
        // =========================================
        async function loadData() {
            showLoading('正在加载分析数据...');
            const { since, until } = getDateRange(currentRange);

            try {
                // Build the domain filter for GraphQL
                const hostFilter = currentDomain ? `, clientRequestHTTPHost: "${currentDomain}"` : '';

                // Main query: overview + daily trend + domains + pages + geo + browser + status codes
                const query = `
                query Analytics($zoneTag: string!, $since: Date!, $until: Date!) {
                    viewer {
                        zones(filter: {zoneTag: $zoneTag}) {
                            # Daily overview totals
                            totals: httpRequests1dGroups(
                                filter: {date_geq: $since, date_leq: $until${hostFilter}}
                                limit: 1000
                            ) {
                                sum {
                                    requests
                                    pageViews
                                    bytes
                                    cachedBytes
                                    threats
                                    encryptedRequests
                                }
                                uniq {
                                    uniques
                                }
                            }

                            # Daily trend
                            trend: httpRequests1dGroups(
                                filter: {date_geq: $since, date_leq: $until${hostFilter}}
                                orderBy: [date_ASC]
                                limit: 1000
                            ) {
                                dimensions {
                                    date
                                }
                                sum {
                                    requests
                                    pageViews
                                    bytes
                                }
                                uniq {
                                    uniques
                                }
                            }

                            # By hostname (domain/subdomain)
                            hostnames: httpRequests1dGroups(
                                filter: {date_geq: $since, date_leq: $until}
                                limit: 100
                            ) {
                                dimensions {
                                    date
                                }
                                sum {
                                    requests
                                    bytes
                                    countryMap {
                                        clientCountryName
                                        requests
                                        bytes
                                        threats
                                    }
                                    responseStatusMap {
                                        edgeResponseStatus
                                        requests
                                    }
                                    browserMap {
                                        uaBrowserFamily
                                        pageViews
                                    }
                                }
                                uniq {
                                    uniques
                                }
                            }

                            # Top paths (via httpRequestsAdaptiveGroups for more granularity)
                            topPaths: httpRequests1dGroups(
                                filter: {date_geq: $since, date_leq: $until${hostFilter}}
                                limit: 1000
                            ) {
                                sum {
                                    requests
                                    bytes
                                }
                                uniq {
                                    uniques
                                }
                            }
                        }
                    }
                }`;

                const data = await cfGql(query, {
                    zoneTag: currentZoneId,
                    since: since,
                    until: until
                });

                const zone = data.viewer.zones[0];
                if (!zone) {
                    showError('未获取到该域名的分析数据');
                    return;
                }

                processOverview(zone.totals);
                processTrend(zone.trend);
                processHostnames(zone.hostnames);
                processSecurityAndBrowser(zone.hostnames);

                // Now try adaptive groups for domain + path detail
                await loadAdaptiveData(since, until, hostFilter);

                renderAll();
                showDashboard();
            } catch (err) {
                console.error('Analytics load error:', err);
                // If GraphQL query fails, try a simpler approach
                try {
                    await loadSimpleData();
                } catch (err2) {
                    showError('加载分析数据失败: ' + err.message + '<br><br>提示：确保 API Token 具有 Analytics 读取权限');
                }
            }
        }

        // Simpler fallback query
        async function loadSimpleData() {
            showLoading('尝试基础查询...');
            const { since, until } = getDateRange(currentRange);
            const hostFilter = currentDomain ? `, clientRequestHTTPHost: "${currentDomain}"` : '';

            const query = `
            query SimpleAnalytics($zoneTag: string!, $since: Date!, $until: Date!) {
                viewer {
                    zones(filter: {zoneTag: $zoneTag}) {
                        totals: httpRequests1dGroups(
                            filter: {date_geq: $since, date_leq: $until${hostFilter}}
                            limit: 1000
                        ) {
                            dimensions { date }
                            sum {
                                requests
                                pageViews
                                bytes
                                cachedBytes
                                threats
                                encryptedRequests
                                countryMap {
                                    clientCountryName
                                    requests
                                    bytes
                                }
                                responseStatusMap {
                                    edgeResponseStatus
                                    requests
                                }
                                browserMap {
                                    uaBrowserFamily
                                    pageViews
                                }
                            }
                            uniq { uniques }
                        }
                    }
                }
            }`;

            const data = await cfGql(query, {
                zoneTag: currentZoneId,
                since: since,
                until: until
            });

            const zone = data.viewer.zones[0];
            if (!zone) {
                showError('未获取到该域名的分析数据');
                return;
            }

            processAllFromDailyGroups(zone.totals);
            renderAll();
            showDashboard();
        }

        // Process all data from daily groups
        function processAllFromDailyGroups(groups) {
            if (!groups || groups.length === 0) {
                dataOverview = { requests: 0, pageViews: 0, uniques: 0, bytes: 0, cachedBytes: 0, threats: 0, encryptedRequests: 0 };
                dataTrend = [];
                dataGeo = [];
                dataBrowsers = [];
                dataSecurity = { threats: 0, httpsPercentage: 0, cacheHitRate: 0, cachedBytes: 0, statusCodes: [] };
                return;
            }

            // Aggregate overview
            let totalRequests = 0, totalPageViews = 0, totalUniques = 0, totalBytes = 0, totalCachedBytes = 0, totalThreats = 0, totalEncrypted = 0;
            const geoMap = {};
            const browserMap = {};
            const statusMap = {};

            groups.forEach(g => {
                totalRequests += g.sum.requests || 0;
                totalPageViews += g.sum.pageViews || 0;
                totalUniques += g.uniq.uniques || 0;
                totalBytes += g.sum.bytes || 0;
                totalCachedBytes += g.sum.cachedBytes || 0;
                totalThreats += g.sum.threats || 0;
                totalEncrypted += g.sum.encryptedRequests || 0;

                (g.sum.countryMap || []).forEach(c => {
                    if (!geoMap[c.clientCountryName]) geoMap[c.clientCountryName] = { requests: 0, bytes: 0 };
                    geoMap[c.clientCountryName].requests += c.requests || 0;
                    geoMap[c.clientCountryName].bytes += c.bytes || 0;
                });

                (g.sum.browserMap || []).forEach(b => {
                    const name = b.uaBrowserFamily || 'Other';
                    if (!browserMap[name]) browserMap[name] = 0;
                    browserMap[name] += b.pageViews || 0;
                });

                (g.sum.responseStatusMap || []).forEach(s => {
                    const code = s.edgeResponseStatus;
                    if (!statusMap[code]) statusMap[code] = 0;
                    statusMap[code] += s.requests || 0;
                });
            });

            dataOverview = {
                requests: totalRequests,
                pageViews: totalPageViews,
                uniques: totalUniques,
                bytes: totalBytes,
                cachedBytes: totalCachedBytes,
                threats: totalThreats,
                encryptedRequests: totalEncrypted
            };

            dataTrend = groups.map(g => ({
                date: g.dimensions.date,
                requests: g.sum.requests || 0,
                pageViews: g.sum.pageViews || 0,
                uniques: g.uniq.uniques || 0,
                bytes: g.sum.bytes || 0
            })).sort((a, b) => a.date.localeCompare(b.date));

            dataGeo = Object.entries(geoMap)
                .map(([country, d]) => ({ country, requests: d.requests, bytes: d.bytes }))
                .sort((a, b) => b.requests - a.requests);

            dataBrowsers = Object.entries(browserMap)
                .map(([name, pageViews]) => ({ name, pageViews }))
                .sort((a, b) => b.pageViews - a.pageViews);

            const httpsPercent = totalRequests > 0 ? ((totalEncrypted / totalRequests) * 100).toFixed(1) : 0;
            const cacheHitRate = totalRequests > 0 ? ((totalCachedBytes / totalBytes) * 100).toFixed(1) : 0;

            dataSecurity = {
                threats: totalThreats,
                httpsPercentage: httpsPercent,
                cacheHitRate: cacheHitRate,
                cachedBytes: totalCachedBytes,
                statusCodes: Object.entries(statusMap)
                    .map(([code, requests]) => ({ code: parseInt(code), requests }))
                    .sort((a, b) => b.requests - a.requests)
            };
        }

        // Load adaptive groups for domain + path breakdown
        async function loadAdaptiveData(since, until, hostFilter) {
            try {
                const query = `
                query AdaptiveAnalytics($zoneTag: string!, $since: Date!, $until: Date!) {
                    viewer {
                        zones(filter: {zoneTag: $zoneTag}) {
                            # By hostname
                            byHost: httpRequestsAdaptiveGroups(
                                filter: {date_geq: $since, date_leq: $until}
                                limit: 100
                            ) {
                                count
                                dimensions {
                                    clientRequestHTTPHost
                                }
                                avg {
                                    sampleInterval
                                }
                            }

                            # Top paths
                            byPath: httpRequestsAdaptiveGroups(
                                filter: {date_geq: $since, date_leq: $until${hostFilter}}
                                limit: 50
                            ) {
                                count
                                dimensions {
                                    clientRequestPath
                                    clientRequestHTTPHost
                                }
                                avg {
                                    sampleInterval
                                }
                            }
                        }
                    }
                }`;

                const data = await cfGql(query, {
                    zoneTag: currentZoneId,
                    since: since,
                    until: until
                });

                const zone = data.viewer.zones[0];
                if (zone) {
                    processDomainAdaptive(zone.byHost);
                    processPathAdaptive(zone.byPath);
                }
            } catch (e) {
                // Adaptive groups may not be available, that's OK
                console.log('Adaptive groups not available:', e.message);
            }
        }

        // =========================================
        // Data processors
        // =========================================
        function processOverview(groups) {
            if (!groups || groups.length === 0) {
                dataOverview = { requests: 0, pageViews: 0, uniques: 0, bytes: 0, cachedBytes: 0, threats: 0, encryptedRequests: 0 };
                return;
            }
            let requests = 0, pageViews = 0, uniques = 0, bytes = 0, cachedBytes = 0, threats = 0, encrypted = 0;
            groups.forEach(g => {
                requests += g.sum.requests || 0;
                pageViews += g.sum.pageViews || 0;
                uniques += g.uniq.uniques || 0;
                bytes += g.sum.bytes || 0;
                cachedBytes += g.sum.cachedBytes || 0;
                threats += g.sum.threats || 0;
                encrypted += g.sum.encryptedRequests || 0;
            });
            dataOverview = { requests, pageViews, uniques, bytes, cachedBytes, threats, encryptedRequests: encrypted };
        }

        function processTrend(groups) {
            if (!groups) { dataTrend = []; return; }
            dataTrend = groups.map(g => ({
                date: g.dimensions.date,
                requests: g.sum.requests || 0,
                pageViews: g.sum.pageViews || 0,
                uniques: g.uniq.uniques || 0,
                bytes: g.sum.bytes || 0
            })).sort((a, b) => a.date.localeCompare(b.date));
        }

        function processHostnames(groups) {
            // For domain table, if adaptive data is not available, aggregate from daily hostnames
            // This is a fallback - real domain data comes from adaptive groups
        }

        function processSecurityAndBrowser(groups) {
            if (!groups || groups.length === 0) {
                dataSecurity = { threats: 0, httpsPercentage: 0, cacheHitRate: 0, cachedBytes: 0, statusCodes: [] };
                dataBrowsers = [];
                dataGeo = [];
                return;
            }

            const geoMap = {};
            const browserMap = {};
            const statusMap = {};
            let totalRequests = 0;

            groups.forEach(g => {
                totalRequests += g.sum.requests || 0;
                (g.sum.countryMap || []).forEach(c => {
                    if (!geoMap[c.clientCountryName]) geoMap[c.clientCountryName] = { requests: 0, bytes: 0 };
                    geoMap[c.clientCountryName].requests += c.requests || 0;
                    geoMap[c.clientCountryName].bytes += c.bytes || 0;
                });
                (g.sum.browserMap || []).forEach(b => {
                    const name = b.uaBrowserFamily || 'Other';
                    if (!browserMap[name]) browserMap[name] = 0;
                    browserMap[name] += b.pageViews || 0;
                });
                (g.sum.responseStatusMap || []).forEach(s => {
                    const code = s.edgeResponseStatus;
                    if (!statusMap[code]) statusMap[code] = 0;
                    statusMap[code] += s.requests || 0;
                });
            });

            dataGeo = Object.entries(geoMap)
                .map(([country, d]) => ({ country, requests: d.requests, bytes: d.bytes }))
                .sort((a, b) => b.requests - a.requests);

            dataBrowsers = Object.entries(browserMap)
                .map(([name, pageViews]) => ({ name, pageViews }))
                .sort((a, b) => b.pageViews - a.pageViews);

            const o = dataOverview || {};
            const httpsPercent = o.requests > 0 ? ((o.encryptedRequests / o.requests) * 100).toFixed(1) : 0;
            const cacheHitRate = o.bytes > 0 ? ((o.cachedBytes / o.bytes) * 100).toFixed(1) : 0;

            dataSecurity = {
                threats: o.threats || 0,
                httpsPercentage: httpsPercent,
                cacheHitRate: cacheHitRate,
                cachedBytes: o.cachedBytes || 0,
                statusCodes: Object.entries(statusMap)
                    .map(([code, requests]) => ({ code: parseInt(code), requests }))
                    .sort((a, b) => b.requests - a.requests)
            };
        }

        function processDomainAdaptive(groups) {
            if (!groups || groups.length === 0) return;
            const domainMap = {};
            groups.forEach(g => {
                const host = g.dimensions.clientRequestHTTPHost || 'unknown';
                if (!domainMap[host]) domainMap[host] = { requests: 0, uniques: 0, bytes: 0 };
                const estimated = Math.round(g.count * (g.avg.sampleInterval || 1));
                domainMap[host].requests += estimated;
            });
            const totalRequests = Object.values(domainMap).reduce((s, d) => s + d.requests, 0);
            dataDomains = Object.entries(domainMap)
                .map(([domain, d]) => ({
                    domain,
                    requests: d.requests,
                    uniques: d.uniques,
                    bytes: d.bytes,
                    percentage: totalRequests > 0 ? ((d.requests / totalRequests) * 100).toFixed(1) : 0
                }))
                .sort((a, b) => b.requests - a.requests);

            // Update domain filter
            renderDomainFilter();
        }

        function processPathAdaptive(groups) {
            if (!groups || groups.length === 0) return;
            const pathMap = {};
            groups.forEach(g => {
                const path = g.dimensions.clientRequestPath || '/';
                const host = g.dimensions.clientRequestHTTPHost || '';
                const key = host + path;
                if (!pathMap[key]) pathMap[key] = { path, host, requests: 0, uniques: 0 };
                const estimated = Math.round(g.count * (g.avg.sampleInterval || 1));
                pathMap[key].requests += estimated;
            });
            const totalRequests = Object.values(pathMap).reduce((s, d) => s + d.requests, 0);
            dataPages = Object.entries(pathMap)
                .map(([_, d]) => ({
                    path: d.path,
                    host: d.host,
                    requests: d.requests,
                    uniques: d.uniques,
                    percentage: totalRequests > 0 ? ((d.requests / totalRequests) * 100).toFixed(1) : 0
                }))
                .sort((a, b) => b.requests - a.requests)
                .slice(0, 30);
        }

        // =========================================
        // Render All
        // =========================================
        function renderAll() {
            renderOverview();
            renderChart();
            renderDomainTable();
            renderPageTable();
            renderGeoBars();
            renderBrowserBars();
            renderSecurity();
        }

        // =========================================
        // Render: Overview metrics
        // =========================================
        function renderOverview() {
            const o = dataOverview || {};
            document.getElementById('mRequests').textContent = formatNum(o.requests);
            document.getElementById('mPageViews').textContent = formatNum(o.pageViews);
            document.getElementById('mUniques').textContent = formatNum(o.uniques);
            document.getElementById('mBandwidth').textContent = formatBytes(o.bytes);

            const rangeLabel = currentRange === 1 ? '今日' : `过去 ${currentRange} 天`;
            document.getElementById('mRequestsSub').textContent = rangeLabel;
            document.getElementById('mPageViewsSub').textContent = rangeLabel;
            document.getElementById('mUniquesSub').textContent = rangeLabel;
            document.getElementById('mBandwidthSub').textContent = rangeLabel;
        }

        // =========================================
        // Render: Domain filter
        // =========================================
        function renderDomainFilter() {
            const prev = domainFilter.value;
            domainFilter.innerHTML = '<option value="">全部域名</option>';
            dataDomains.forEach(d => {
                const opt = document.createElement('option');
                opt.value = d.domain;
                opt.textContent = d.domain;
                domainFilter.appendChild(opt);
            });
            domainFilter.value = prev || '';
        }

        // =========================================
        // Render: Domain table
        // =========================================
        function renderDomainTable() {
            const sorted = [...dataDomains].sort((a, b) => {
                const va = a[domainSortKey] || 0;
                const vb = b[domainSortKey] || 0;
                return domainSortDir === 'desc' ? vb - va : va - vb;
            });

            document.querySelectorAll('#domainTable th.sortable').forEach(th => {
                th.classList.remove('sorted-asc', 'sorted-desc');
                if (th.dataset.key === domainSortKey) {
                    th.classList.add(domainSortDir === 'desc' ? 'sorted-desc' : 'sorted-asc');
                }
            });

            const tbody = document.querySelector('#domainTable tbody');
            tbody.innerHTML = '';
            if (sorted.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" style="text-align:center;color:rgba(255,255,255,0.3);padding:30px;">暂无域名数据（需要 Adaptive Analytics 权限）</td></tr>';
                return;
            }
            const maxReq = sorted[0]?.requests || 1;
            sorted.forEach(d => {
                const tr = document.createElement('tr');
                const barW = Math.max((d.requests / maxReq) * 100, 2);
                tr.innerHTML = `
                    <td>${escapeHtml(d.domain)}</td>
                    <td class="num-cell">${formatNum(d.requests)}<div class="bar-bg"><div class="bar-fill" style="width:${barW}%"></div></div></td>
                    <td class="num-cell">${formatNum(d.uniques) || '-'}</td>
                    <td class="num-cell">${formatBytes(d.bytes)}</td>
                    <td class="num-cell">${d.percentage}%</td>`;
                tbody.appendChild(tr);
            });
        }

        // =========================================
        // Render: Page table
        // =========================================
        function renderPageTable() {
            const sorted = [...dataPages].sort((a, b) => {
                const va = a[pageSortKey] || 0;
                const vb = b[pageSortKey] || 0;
                return pageSortDir === 'desc' ? vb - va : va - vb;
            });

            document.querySelectorAll('#pageTable th.sortable').forEach(th => {
                th.classList.remove('sorted-asc', 'sorted-desc');
                if (th.dataset.key === pageSortKey) {
                    th.classList.add(pageSortDir === 'desc' ? 'sorted-desc' : 'sorted-asc');
                }
            });

            const tbody = document.querySelector('#pageTable tbody');
            tbody.innerHTML = '';
            if (sorted.length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" style="text-align:center;color:rgba(255,255,255,0.3);padding:30px;">暂无页面数据</td></tr>';
                return;
            }
            sorted.forEach(p => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td title="${escapeHtml(p.host + p.path)}">${escapeHtml(p.path)}</td>
                    <td class="num-cell">${formatNum(p.requests)}</td>
                    <td class="num-cell">${formatNum(p.uniques) || '-'}</td>
                    <td class="num-cell">${p.percentage}%</td>`;
                tbody.appendChild(tr);
            });
        }

        // =========================================
        // Render: Geo bars
        // =========================================
        const BAR_COLORS = [
            'rgba(100,180,255,0.7)', 'rgba(100,255,160,0.7)', 'rgba(255,200,100,0.7)',
            'rgba(255,130,180,0.7)', 'rgba(180,130,255,0.7)', 'rgba(130,220,220,0.7)',
            'rgba(255,160,100,0.7)', 'rgba(200,200,100,0.7)', 'rgba(100,200,255,0.7)',
            'rgba(200,100,255,0.7)'
        ];

        function renderGeoBars() {
            const container = document.getElementById('geoBars');
            container.innerHTML = '';
            const top = dataGeo.slice(0, 10);
            if (top.length === 0) {
                container.innerHTML = '<div style="color:rgba(255,255,255,0.3);font-size:13px;padding:20px 0;">暂无数据</div>';
                return;
            }
            const maxReq = top[0]?.requests || 1;
            top.forEach((g, i) => {
                const pct = ((g.requests / maxReq) * 100).toFixed(0);
                const div = document.createElement('div');
                div.className = 'bar-item';
                div.innerHTML = `<span class="bar-label">${escapeHtml(g.country)}</span><div class="bar-track"><div class="bar-fill-h" style="width:${pct}%;background:${BAR_COLORS[i % BAR_COLORS.length]}"></div></div><span class="bar-val">${formatNum(g.requests)}</span>`;
                container.appendChild(div);
            });
        }

        // =========================================
        // Render: Browser bars
        // =========================================
        function renderBrowserBars() {
            const container = document.getElementById('browserBars');
            container.innerHTML = '';
            const top = dataBrowsers.slice(0, 8);
            if (top.length === 0) {
                container.innerHTML = '<div style="color:rgba(255,255,255,0.3);font-size:13px;padding:20px 0;">暂无数据</div>';
                return;
            }
            const maxVal = top[0]?.pageViews || 1;
            top.forEach((b, i) => {
                const pct = ((b.pageViews / maxVal) * 100).toFixed(0);
                const div = document.createElement('div');
                div.className = 'bar-item';
                div.innerHTML = `<span class="bar-label">${escapeHtml(b.name)}</span><div class="bar-track"><div class="bar-fill-h" style="width:${pct}%;background:${BAR_COLORS[i % BAR_COLORS.length]}"></div></div><span class="bar-val">${formatNum(b.pageViews)}</span>`;
                container.appendChild(div);
            });
        }

        // =========================================
        // Render: Security
        // =========================================
        function renderSecurity() {
            if (!dataSecurity) return;
            document.getElementById('mThreats').textContent = formatNum(dataSecurity.threats);
            document.getElementById('mHttps').textContent = dataSecurity.httpsPercentage + '%';
            document.getElementById('mCacheHit').textContent = dataSecurity.cacheHitRate + '%';
            document.getElementById('mCachedBW').textContent = formatBytes(dataSecurity.cachedBytes);

            const grid = document.getElementById('statusGrid');
            grid.innerHTML = '';
            (dataSecurity.statusCodes || []).forEach(s => {
                const span = document.createElement('span');
                let cls = '';
                if (s.code >= 200 && s.code < 300) cls = 's2xx';
                else if (s.code >= 300 && s.code < 400) cls = 's3xx';
                else if (s.code >= 400 && s.code < 500) cls = 's4xx';
                else if (s.code >= 500) cls = 's5xx';
                span.className = 'status-badge ' + cls;
                span.textContent = s.code + ': ' + formatNum(s.requests);
                grid.appendChild(span);
            });
        }

        // =========================================
        // Trend Chart (Canvas)
        // =========================================
        let chartPoints = [];

        function renderChart() {
            const trend = dataTrend;
            const chartCanvas = document.getElementById('trendChart');
            const container = chartCanvas.parentElement;
            const dpr = window.devicePixelRatio || 1;
            const displayW = container.clientWidth - 48;
            const displayH = 300;
            chartCanvas.style.width = displayW + 'px';
            chartCanvas.style.height = displayH + 'px';
            chartCanvas.width = displayW * dpr;
            chartCanvas.height = displayH * dpr;
            const ctx = chartCanvas.getContext('2d');
            ctx.scale(dpr, dpr);

            const padL = 56, padR = 20, padT = 20, padB = 50;
            const cw = displayW - padL - padR;
            const ch = displayH - padT - padB;

            ctx.clearRect(0, 0, displayW, displayH);

            if (trend.length === 0) {
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.font = '14px -apple-system, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('暂无趋势数据', displayW / 2, displayH / 2);
                chartPoints = [];
                return;
            }

            // Three lines: requests, pageViews, uniques
            const reqData = trend.map(t => t.requests || 0);
            const pvData = trend.map(t => t.pageViews || 0);
            const uvData = trend.map(t => t.uniques || 0);
            const labels = trend.map(t => t.date || '');
            const maxVal = Math.max(Math.max(...reqData), Math.max(...pvData), Math.max(...uvData), 1);

            const tickCount = 5;
            const niceMax = niceNum(maxVal, tickCount);
            const tickStep = niceMax / tickCount;

            // Grid
            ctx.strokeStyle = 'rgba(255,255,255,0.06)';
            ctx.lineWidth = 1;
            ctx.fillStyle = 'rgba(255,255,255,0.35)';
            ctx.font = '11px -apple-system, sans-serif';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            for (let i = 0; i <= tickCount; i++) {
                const val = tickStep * i;
                const y = padT + ch - (val / niceMax) * ch;
                ctx.beginPath();
                ctx.moveTo(padL, y);
                ctx.lineTo(padL + cw, y);
                ctx.stroke();
                ctx.fillText(formatTickLabel(val), padL - 8, y);
            }

            // X labels
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            const labelInterval = Math.max(1, Math.floor(labels.length / 8));
            labels.forEach((label, i) => {
                if (i % labelInterval === 0 || i === labels.length - 1) {
                    const x = padL + (i / Math.max(labels.length - 1, 1)) * cw;
                    ctx.fillText(formatDateLabel(label), x, padT + ch + 10);
                }
            });

            chartPoints = [];
            function getX(i) { return padL + (i / Math.max(trend.length - 1, 1)) * cw; }
            function getY(val) { return padT + ch - (val / niceMax) * ch; }

            // Draw lines: Requests (blue), PageViews (green), Uniques (orange)
            drawLine(ctx, reqData, getX, getY, 'rgba(100,180,255,0.8)', 'rgba(100,180,255,0.05)', padT, ch);
            drawLine(ctx, pvData, getX, getY, 'rgba(100,255,160,0.8)', 'rgba(100,255,160,0.05)', padT, ch);
            drawLine(ctx, uvData, getX, getY, 'rgba(255,200,100,0.8)', 'rgba(255,200,100,0.05)', padT, ch);

            // Dots & points
            for (let i = 0; i < trend.length; i++) {
                const x = getX(i);
                // Requests dot
                ctx.beginPath(); ctx.arc(x, getY(reqData[i]), 3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(100,180,255,0.9)'; ctx.fill();
                // PV dot
                ctx.beginPath(); ctx.arc(x, getY(pvData[i]), 3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(100,255,160,0.9)'; ctx.fill();
                // UV dot
                ctx.beginPath(); ctx.arc(x, getY(uvData[i]), 2.5, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,200,100,0.9)'; ctx.fill();

                chartPoints.push({ x, date: labels[i], requests: reqData[i], pv: pvData[i], uv: uvData[i] });
            }

            // Legend
            const legendY = padT + ch + 32;
            ctx.font = '11px -apple-system, sans-serif';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            let lx = padL;

            ctx.fillStyle = 'rgba(100,180,255,0.9)';
            ctx.fillRect(lx, legendY - 4, 16, 8); lx += 20;
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.fillText('请求', lx, legendY); lx += 40;

            ctx.fillStyle = 'rgba(100,255,160,0.9)';
            ctx.fillRect(lx, legendY - 4, 16, 8); lx += 20;
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.fillText('PV', lx, legendY); lx += 30;

            ctx.fillStyle = 'rgba(255,200,100,0.9)';
            ctx.fillRect(lx, legendY - 4, 16, 8); lx += 20;
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.fillText('UV', lx, legendY);
        }

        function drawLine(ctx, data, getX, getY, strokeColor, fillColor, padT, ch) {
            if (data.length === 0) return;
            ctx.beginPath();
            ctx.moveTo(getX(0), getY(data[0]));
            for (let i = 1; i < data.length; i++) ctx.lineTo(getX(i), getY(data[i]));
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 2;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.stroke();
            ctx.lineTo(getX(data.length - 1), padT + ch);
            ctx.lineTo(getX(0), padT + ch);
            ctx.closePath();
            ctx.fillStyle = fillColor;
            ctx.fill();
        }

        function niceNum(maxVal, tickCount) {
            const rough = maxVal / tickCount;
            const pow10 = Math.pow(10, Math.floor(Math.log10(Math.max(rough, 1))));
            const frac = rough / pow10;
            let nice;
            if (frac <= 1.5) nice = 1;
            else if (frac <= 3) nice = 2;
            else if (frac <= 7) nice = 5;
            else nice = 10;
            return nice * pow10 * tickCount;
        }

        function formatTickLabel(val) {
            if (val >= 10000) return (val / 10000).toFixed(val % 10000 === 0 ? 0 : 1) + '万';
            if (val >= 1000) return (val / 1000).toFixed(val % 1000 === 0 ? 0 : 1) + 'k';
            return Math.round(val).toString();
        }

        function formatDateLabel(dateStr) {
            if (!dateStr) return '';
            if (dateStr.includes('T')) {
                const d = new Date(dateStr);
                return (d.getMonth() + 1) + '/' + d.getDate() + ' ' + d.getHours() + ':00';
            }
            const parts = dateStr.split('-');
            if (parts.length >= 3) return parts[1] + '/' + parts[2];
            return dateStr;
        }

        // =========================================
        // Chart Tooltip
        // =========================================
        const trendChart = document.getElementById('trendChart');
        trendChart.addEventListener('mousemove', function(e) {
            if (chartPoints.length === 0) { chartTooltip.style.display = 'none'; return; }
            const rect = trendChart.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            let closest = null, minDist = Infinity;
            chartPoints.forEach(p => {
                const dist = Math.abs(p.x - mx);
                if (dist < minDist) { minDist = dist; closest = p; }
            });
            if (closest && minDist < 40) {
                chartTooltip.style.display = 'block';
                chartTooltip.innerHTML = `${formatDateLabel(closest.date)}<br>请求: ${formatNum(closest.requests)}<br>PV: ${formatNum(closest.pv)}<br>UV: ${formatNum(closest.uv)}`;
                const containerRect = trendChart.parentElement.getBoundingClientRect();
                let tx = e.clientX - containerRect.left + 16;
                let ty = e.clientY - containerRect.top - 10;
                if (tx + 160 > containerRect.width) tx = tx - 180;
                if (ty < 0) ty = 10;
                chartTooltip.style.left = tx + 'px';
                chartTooltip.style.top = ty + 'px';
            } else {
                chartTooltip.style.display = 'none';
            }
        });
        trendChart.addEventListener('mouseleave', function() { chartTooltip.style.display = 'none'; });

        // =========================================
        // Event Listeners
        // =========================================

        // Zone selector
        zoneSelect.addEventListener('change', function() {
            currentZoneId = this.value;
            currentZoneName = this.options[this.selectedIndex].text;
            currentDomain = '';
            domainFilter.value = '';
            loadData();
        });

        // Range buttons
        document.querySelectorAll('.range-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.range-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                currentRange = parseInt(this.dataset.range);
                loadData();
            });
        });

        // Domain filter
        domainFilter.addEventListener('change', function() {
            currentDomain = this.value;
            loadData();
        });

        // Table sorting
        document.querySelectorAll('th.sortable').forEach(th => {
            th.addEventListener('click', function() {
                const table = this.dataset.table;
                const key = this.dataset.key;
                if (table === 'domain') {
                    if (domainSortKey === key) domainSortDir = domainSortDir === 'desc' ? 'asc' : 'desc';
                    else { domainSortKey = key; domainSortDir = 'desc'; }
                    renderDomainTable();
                } else if (table === 'page') {
                    if (pageSortKey === key) pageSortDir = pageSortDir === 'desc' ? 'asc' : 'desc';
                    else { pageSortKey = key; pageSortDir = 'desc'; }
                    renderPageTable();
                }
            });
        });

        // Resize
        let resizeTimer;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(function() { if (dataTrend.length > 0) renderChart(); }, 200);
        });

        // =========================================
        // Init
        // =========================================
        async function init() {
            const hasZones = await loadZones();
            if (hasZones) {
                await loadData();
            }
        }

        init();

    })();
    </script>
</body>
</html>
